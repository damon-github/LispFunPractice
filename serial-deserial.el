(defun serial (root &optional result)
  (let ((queue '())
	(ret '())
	)
    (add-to-list 'queue root t)
    (while queue
      (setf node (pop queue))
      (if node
	  (progn
	    (setf ret (append ret (cons (car node) nil)))
	    (setf queue (append queue (cons (nth 1 node) nil)))
	    (setf queue (append queue (cons (nth 2 node) nil))))
	(setf ret (append ret (cons nil nil)))))
    (setf result ret))
  result)


(defun deserial (serial &optional tree oldBtnList  newBtnList )
  (or tree (setq tree '()))
  (or oldBtnList (setq oldBtnList '()))
  (or newBtnList (setq newBtnList '()))
  (cond ((eq (length serial) 0)
	 tree
	 )

	((when (> (length oldBtnList) 0)
	  (setq node (car oldBtnList)) 
	  (cond ((eq (nthcdr 1 node) nil)
		 (setq newNode (car (setcdr node (list (unless (eq (car serial) nil)
						 (list (car serial)))
						       ))))
		 (if newBtnList
		     (unless (eq (car newNode) nil)
			 (setcdr (nthcdr (- (length newBtnList) 1) newBtnList) (list newNode))
		       )
		   (unless (eq (car newNode) nil)
		     (setq newBtnList (list newNode))) 
		   )  
		   (deserial (cdr serial) tree oldBtnList newBtnList)
		 )
		((eq (nthcdr 2 node) nil)
		 (setq newNode (car (setcdr (nthcdr 1 node) (list (unless (eq (car serial) nil)
								    (list (car serial)))))))
		 (unless (eq newNode nil)
		   (if (eq newBtnList nil)
		       (setq newBtnList (list newNode))
		     (setcdr (nthcdr (- (length newBtnList) 1) newBtnList) (list newNode))
		     )
		   )
		 (deserial (cdr serial) tree (cdr oldBtnList) newBtnList)
		 )
	      )
	  )
	 )
	
	((when (eq (length oldBtnList) 0)
	  (if (eq (length newBtnList) 0)
	      (progn
		(setq tree (list (car serial)))
		(setq oldBtnList (list tree))
		(deserial (cdr serial) tree oldBtnList newBtnList) 
		)
	    (progn
	      (setq oldBtnList (copy-sequence newBtnList))
	      (setq newBtnList nil)
	      (deserial serial tree oldBtnList newBtnList)
	      )
	    )
	  )
	 )
      )
  )
